{"intl":"var _=function(){var D={\"en\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n","src":"/** @module tfw.pointer-events */require( 'tfw.pointer-events', function(require, module, exports) { var _=function(){var D={\"en\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n    /**\r\n * @module tfw.pointer-events\r\n *\r\n * @description\r\n *\r\n *\r\n * @example\r\n * var mod = require('tfw.pointer-events');\r\n */\r\n\r\n// Webkit and Opera still use 'mousewheel' event type.\r\nvar WHEEL_EVENT = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\r\n        document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\r\n        \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n\r\nvar G = {\r\n    // As soon as a touch occurs, no more mouse events can be handled.\r\n    touchDevice: false,\r\n    // When a DOM element is touched, `target` holds it.\r\n    // Then we can track mouse events on __body__ using capture.\r\n    target: null,\r\n    // Coords of _down_ on target.\r\n    targetX: 0, targetY: 0,\r\n    // Coords of _down_ on body.\r\n    bodyDownX: 0, bodyDownY: 0,\r\n    // Current mouse position on body.\r\n    bodyMoveX: -1, bodyMoveY: -1,\r\n    // Last mouse position on body.\r\n    bodyMoveLastX: -1, bodyMoveLastY: -1,\r\n    // drag event.\r\n    onDrag: null,\r\n    // Last time tap for double tap detection.\r\n    lastTapTime: 0\r\n};\r\n\r\ndocument.body.addEventListener( 'mousedown', function(evt) {\r\n    if (G.touchDevice) return;\r\n    G.bodyDownX = evt.clientX;\r\n    G.bodyDownY = evt.clientY;\r\n    G.bodyMoveX = evt.clientX;\r\n    G.bodyMoveY = evt.clientY;\r\n    G.bodyMoveLastX = evt.clientX;\r\n    G.bodyMoveLastY = evt.clientY;\r\n}, true );\r\n\r\ndocument.body.addEventListener( 'mousemove', function(evt) {\r\n    if (G.touchDevice) return;\r\n    G.bodyMoveLastX = G.bodyMoveX;\r\n    G.bodyMoveLastY = G.bodyMoveY;\r\n    var rectB = evt.target.getBoundingClientRect();\r\n    G.bodyMoveX = evt.offsetX + rectB.left;\r\n    G.bodyMoveY = evt.offsetY + rectB.top;\r\n\r\n    if (!G.target) return;\r\n\r\n    var slots = G.target._slots;\r\n    if (typeof slots.drag !== 'function') return;\r\n\r\n    slots.drag({\r\n        action: 'drag',\r\n        target: G.target.element,\r\n        x0: G.targetX,\r\n        y0: G.targetY,\r\n        x: G.targetX + G.bodyMoveX - G.bodyDownX,\r\n        y: G.targetY + G.bodyMoveY - G.bodyDownY,\r\n        dx: G.bodyMoveX - G.bodyDownX,\r\n        dy: G.bodyMoveY - G.bodyDownY,\r\n        vx: G.bodyMoveX - G.bodyMoveLastX,\r\n        vy: G.bodyMoveY - G.bodyMoveLastY\r\n    });\r\n}, true );\r\n\r\ndocument.body.addEventListener( 'mouseup', function(evt) {\r\n    if (G.touchDevice) return;\r\n    if (!G.target) return;\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n\r\n    var time = Date.now();\r\n    var slots = G.target._slots;\r\n    var dx = G.bodyMoveX - G.bodyDownX;\r\n    var dy = G.bodyMoveY - G.bodyDownY;\r\n    if (slots.up) {\r\n        slots.up({\r\n            action: 'up',\r\n            target: G.target.element,\r\n            x: G.targetX + dx,\r\n            y: G.targetY + dy,\r\n            dx: dx,\r\n            dy: dy\r\n        });\r\n    }\r\n    // Tap or doubletap.\r\n    if (dx * dx + dy * dy < 256) {\r\n        if (G.lastTapTime > 0) {\r\n            if (slots.doubletap && time - G.lastTapTime < 400) {\r\n                slots.doubletap({\r\n                    action: 'doubletap',\r\n                    target: G.target.element,\r\n                    x: G.targetX + dx,\r\n                    y: G.targetY + dy\r\n                });\r\n            } else {\r\n                G.lastTapTime = 0;\r\n            }\r\n        }\r\n        if (slots.tap && G.lastTapTime == 0) {\r\n            slots.tap({\r\n                action: 'tap',\r\n                target: G.target.element,\r\n                x: G.targetX + dx,\r\n                y: G.targetY + dy\r\n            });\r\n        }\r\n        G.lastTapTime = time;\r\n    }\r\n    delete G.target;\r\n}, true);\r\n\r\n\r\nfunction PointerEvents( element ) {\r\n    var that = this;\r\n\r\n    this._slots = {};\r\n    this._eventListeners = [];\r\n\r\n    Object.defineProperty( PointerEvents.prototype, 'element', {\r\n        value: element, writable: false, configurable: true, enumerable: true\r\n    });\r\n\r\n    //===============\r\n    // Touch events.\r\n    addEvent.call(that, element, 'touchstart', function(evt) {\r\n        G.touchDevice = true;\r\n        var slots = that._slots;\r\n        if (evt.touches.length == 1) {\r\n            G.rect = element.getBoundingClientRect();\r\n            G.bodyMoveX = evt.touches[0].clientX;\r\n            G.bodyMoveY = evt.touches[0].clientY;\r\n            G.bodyDownX = evt.touches[0].clientX;\r\n            G.bodyDownY = evt.touches[0].clientY;\r\n            G.targetX = evt.touches[0].clientX - G.rect.left;\r\n            G.targetY = evt.touches[0].clientY - G.rect.top;\r\n            G.time = Date.now();\r\n            if (slots.down) {\r\n                slots.down({\r\n                    action: 'down',\r\n                    target: element,\r\n                    x: G.targetX,\r\n                    y: G.targetY,\r\n                    stopPropagation: evt.stopPropagation.bind( evt ),\r\n                    preventDefault: evt.preventDefault.bind( evt )\r\n                });\r\n            }\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'touchmove', function(evt) {\r\n        var lastX = G.bodyMoveX;\r\n        var lastY = G.bodyMoveY;\r\n        G.bodyMoveX = evt.touches[0].clientX;\r\n        G.bodyMoveY = evt.touches[0].clientY;\r\n        var slots = that._slots;\r\n        if (slots.drag) {\r\n            slots.drag({\r\n                action: 'drag',\r\n                target: element,\r\n                x0: G.targetX,\r\n                y0: G.targetY,\r\n                x: G.bodyMoveX - G.rect.left,\r\n                y: G.bodyMoveY - G.rect.top,\r\n                dx: G.bodyMoveX - G.bodyDownX,\r\n                dy: G.bodyMoveY - G.bodyDownY,\r\n                vx: G.bodyMoveX - lastX,\r\n                vy: G.bodyMoveY - lastY,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'touchend', function(evt) {\r\n        var slots = that._slots;\r\n        var dx = G.bodyMoveX - G.bodyDownX;\r\n        var dy = G.bodyMoveY - G.bodyDownY;\r\n        if (slots.up) {\r\n            slots.up({\r\n                action: 'up',\r\n                target: that.element,\r\n                x: G.bodyMoveX - G.rect.left,\r\n                y: G.bodyMoveY - G.rect.top,\r\n                dx: dx,\r\n                dy: dy,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n        // Tap or doubletap.\r\n        if (dx * dx + dy * dy < 256) {\r\n            var time = Date.now();\r\n            if (G.lastTapTime > 0) {\r\n                if (slots.doubletap && time - G.lastTapTime < 400) {\r\n                    slots.doubletap({\r\n                        action: 'doubletap',\r\n                        target: that.element,\r\n                        x: G.bodyMoveX - G.rect.left,\r\n                        y: G.bodyMoveY - G.rect.top,\r\n                        stopPropagation: evt.stopPropagation.bind( evt ),\r\n                        preventDefault: evt.preventDefault.bind( evt )\r\n                    });\r\n                } else {\r\n                    G.lastTapTime = 0;\r\n                }\r\n            }\r\n            if (slots.tap && G.lastTapTime == 0) {\r\n                evt.stopPropagation();\r\n                evt.preventDefault();\r\n                slots.tap({\r\n                    action: 'tap',\r\n                    target: that.element,\r\n                    x: G.bodyMoveX - G.rect.left,\r\n                    y: G.bodyMoveY - G.rect.top,\r\n                    stopPropagation: evt.stopPropagation.bind( evt ),\r\n                    preventDefault: evt.preventDefault.bind( evt )\r\n                });\r\n            }\r\n            G.lastTapTime = time;\r\n        }\r\n    });\r\n\r\n    //===============\r\n    // Mouse events.\r\n    addEvent.call(that, element, 'mousedown', function(evt) {\r\n        if (G.touchDevice) return;\r\n        var slots = that._slots;\r\n        var rect = element.getBoundingClientRect();\r\n        G.target = that;\r\n        G.targetX = evt.clientX - rect.left;\r\n        G.targetY = evt.clientY - rect.top;\r\n        if (slots.down) {\r\n            slots.down({\r\n                action: 'down',\r\n                target: element,\r\n                x: G.targetX,\r\n                y: G.targetY,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'mousemove', function(evt) {\r\n        var slots = that._slots;\r\n        if (slots.move) {            \r\n            var rectA = element.getBoundingClientRect();\r\n            var rectB = evt.target.getBoundingClientRect();\r\n            slots.move({\r\n                target: element,\r\n                action: 'move',\r\n                x: evt.offsetX + rectB.left - rectA.left,\r\n                y: evt.offsetY + rectB.top - rectA.top\r\n            });\r\n        }\r\n    });\r\n\r\n    Object.defineProperty( this, 'element', {\r\n        value: element, writable: true, configurable: true, enumerable: true\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPointerEvents.prototype.on = function(action, event) {\r\n    var that = this;\r\n\r\n    var slots = this._slots;\r\n    if (typeof event === 'function') {\r\n        slots[action] = event;\r\n    }\r\n    if (action == 'wheel') {\r\n        addEvent.call(that, this.element, WHEEL_EVENT, function(evt) {\r\n            var rect = that.element.getBoundingClientRect();\r\n            slots.wheel({\r\n                target: that.element,\r\n                action: 'wheel',\r\n                delta: evt.deltaY,\r\n                x: evt.clientX - rect.left,\r\n                y: evt.clientY - rect.top,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        });\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPointerEvents.prototype.off = function() {\r\n    this._eventListeners.forEach(function (itm) {\r\n        var element = itm[0];\r\n        var event = itm[1];\r\n        var listener = itm[2];\r\n        var capture = itm[3];\r\n        element.removeEventListener( event, listener, capture );\r\n    });\r\n};\r\n\r\n\r\nfunction addEvent(element, event, listener, capture) {\r\n    element.addEventListener( event, listener, capture );\r\n    this._eventListeners.push([element, event, listener, capture]);\r\n}\r\n\r\nmodule.exports = PointerEvents;\r\n\r\n\r\n  \r\nmodule.exports._ = _;\n/**\n * @module tfw.pointer-events\n * @see module:$\n\n */\n});","zip":"require(\"tfw.pointer-events\",function(t,e,o){function n(t){var e=this;this._slots={},this._eventListeners=[],Object.defineProperty(n.prototype,\"element\",{value:t,writable:!1,configurable:!0,enumerable:!0}),a.call(e,t,\"touchstart\",function(o){d.touchDevice=!0;var n=e._slots;1==o.touches.length&&(d.rect=t.getBoundingClientRect(),d.bodyMoveX=o.touches[0].clientX,d.bodyMoveY=o.touches[0].clientY,d.bodyDownX=o.touches[0].clientX,d.bodyDownY=o.touches[0].clientY,d.targetX=o.touches[0].clientX-d.rect.left,d.targetY=o.touches[0].clientY-d.rect.top,d.time=Date.now(),n.down&&n.down({action:\"down\",target:t,x:d.targetX,y:d.targetY,stopPropagation:o.stopPropagation.bind(o),preventDefault:o.preventDefault.bind(o)}))}),a.call(e,t,\"touchmove\",function(o){var n=d.bodyMoveX,a=d.bodyMoveY;d.bodyMoveX=o.touches[0].clientX,d.bodyMoveY=o.touches[0].clientY;var r=e._slots;r.drag&&r.drag({action:\"drag\",target:t,x0:d.targetX,y0:d.targetY,x:d.bodyMoveX-d.rect.left,y:d.bodyMoveY-d.rect.top,dx:d.bodyMoveX-d.bodyDownX,dy:d.bodyMoveY-d.bodyDownY,vx:d.bodyMoveX-n,vy:d.bodyMoveY-a,stopPropagation:o.stopPropagation.bind(o),preventDefault:o.preventDefault.bind(o)})}),a.call(e,t,\"touchend\",function(t){var o=e._slots,n=d.bodyMoveX-d.bodyDownX,a=d.bodyMoveY-d.bodyDownY;if(o.up&&o.up({action:\"up\",target:e.element,x:d.bodyMoveX-d.rect.left,y:d.bodyMoveY-d.rect.top,dx:n,dy:a,stopPropagation:t.stopPropagation.bind(t),preventDefault:t.preventDefault.bind(t)}),n*n+a*a<256){var r=Date.now();d.lastTapTime>0&&(o.doubletap&&r-d.lastTapTime<400?o.doubletap({action:\"doubletap\",target:e.element,x:d.bodyMoveX-d.rect.left,y:d.bodyMoveY-d.rect.top,stopPropagation:t.stopPropagation.bind(t),preventDefault:t.preventDefault.bind(t)}):d.lastTapTime=0),o.tap&&0==d.lastTapTime&&(t.stopPropagation(),t.preventDefault(),o.tap({action:\"tap\",target:e.element,x:d.bodyMoveX-d.rect.left,y:d.bodyMoveY-d.rect.top,stopPropagation:t.stopPropagation.bind(t),preventDefault:t.preventDefault.bind(t)})),d.lastTapTime=r}}),a.call(e,t,\"mousedown\",function(o){if(!d.touchDevice){var n=e._slots,a=t.getBoundingClientRect();d.target=e,d.targetX=o.clientX-a.left,d.targetY=o.clientY-a.top,n.down&&n.down({action:\"down\",target:t,x:d.targetX,y:d.targetY,stopPropagation:o.stopPropagation.bind(o),preventDefault:o.preventDefault.bind(o)})}}),a.call(e,t,\"mousemove\",function(o){var n=e._slots;if(n.move){var a=t.getBoundingClientRect(),r=o.target.getBoundingClientRect();n.move({target:t,action:\"move\",x:o.offsetX+r.left-a.left,y:o.offsetY+r.top-a.top})}}),Object.defineProperty(this,\"element\",{value:t,writable:!0,configurable:!0,enumerable:!0})}function a(t,e,o,n){t.addEventListener(e,o,n),this._eventListeners.push([t,e,o,n])}var r=function(){function e(){return n(o,arguments)}var o={en:{}},n=t(\"$\").intl;return e.all=o,e}(),i=\"onwheel\"in document.createElement(\"div\")?\"wheel\":void 0!==document.onmousewheel?\"mousewheel\":\"DOMMouseScroll\",d={touchDevice:!1,target:null,targetX:0,targetY:0,bodyDownX:0,bodyDownY:0,bodyMoveX:-1,bodyMoveY:-1,bodyMoveLastX:-1,bodyMoveLastY:-1,onDrag:null,lastTapTime:0};document.body.addEventListener(\"mousedown\",function(t){d.touchDevice||(d.bodyDownX=t.clientX,d.bodyDownY=t.clientY,d.bodyMoveX=t.clientX,d.bodyMoveY=t.clientY,d.bodyMoveLastX=t.clientX,d.bodyMoveLastY=t.clientY)},!0),document.body.addEventListener(\"mousemove\",function(t){if(!d.touchDevice){d.bodyMoveLastX=d.bodyMoveX,d.bodyMoveLastY=d.bodyMoveY;var e=t.target.getBoundingClientRect();if(d.bodyMoveX=t.offsetX+e.left,d.bodyMoveY=t.offsetY+e.top,d.target){var o=d.target._slots;\"function\"==typeof o.drag&&o.drag({action:\"drag\",target:d.target.element,x0:d.targetX,y0:d.targetY,x:d.targetX+d.bodyMoveX-d.bodyDownX,y:d.targetY+d.bodyMoveY-d.bodyDownY,dx:d.bodyMoveX-d.bodyDownX,dy:d.bodyMoveY-d.bodyDownY,vx:d.bodyMoveX-d.bodyMoveLastX,vy:d.bodyMoveY-d.bodyMoveLastY})}}},!0),document.body.addEventListener(\"mouseup\",function(t){if(!d.touchDevice&&d.target){t.stopPropagation(),t.preventDefault();var e=Date.now(),o=d.target._slots,n=d.bodyMoveX-d.bodyDownX,a=d.bodyMoveY-d.bodyDownY;o.up&&o.up({action:\"up\",target:d.target.element,x:d.targetX+n,y:d.targetY+a,dx:n,dy:a}),n*n+a*a<256&&(d.lastTapTime>0&&(o.doubletap&&e-d.lastTapTime<400?o.doubletap({action:\"doubletap\",target:d.target.element,x:d.targetX+n,y:d.targetY+a}):d.lastTapTime=0),o.tap&&0==d.lastTapTime&&o.tap({action:\"tap\",target:d.target.element,x:d.targetX+n,y:d.targetY+a}),d.lastTapTime=e),delete d.target}},!0),n.prototype.on=function(t,e){var o=this,n=this._slots;return\"function\"==typeof e&&(n[t]=e),\"wheel\"==t&&a.call(o,this.element,i,function(t){var e=o.element.getBoundingClientRect();n.wheel({target:o.element,action:\"wheel\",delta:t.deltaY,x:t.clientX-e.left,y:t.clientY-e.top,stopPropagation:t.stopPropagation.bind(t),preventDefault:t.preventDefault.bind(t)})}),this},n.prototype.off=function(){this._eventListeners.forEach(function(t){var e=t[0],o=t[1],n=t[2],a=t[3];e.removeEventListener(o,n,a)})},e.exports=n,e.exports._=r});\n//# sourceMappingURL=tfw.pointer-events.js.map","map":{"version":3,"file":"tfw.pointer-events.js.map","sources":["tfw.pointer-events.js"],"sourcesContent":["/** @module tfw.pointer-events */require( 'tfw.pointer-events', function(require, module, exports) { var _=function(){var D={\"en\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n    /**\r\n * @module tfw.pointer-events\r\n *\r\n * @description\r\n *\r\n *\r\n * @example\r\n * var mod = require('tfw.pointer-events');\r\n */\r\n\r\n// Webkit and Opera still use 'mousewheel' event type.\r\nvar WHEEL_EVENT = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\r\n        document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\r\n        \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n\r\nvar G = {\r\n    // As soon as a touch occurs, no more mouse events can be handled.\r\n    touchDevice: false,\r\n    // When a DOM element is touched, `target` holds it.\r\n    // Then we can track mouse events on __body__ using capture.\r\n    target: null,\r\n    // Coords of _down_ on target.\r\n    targetX: 0, targetY: 0,\r\n    // Coords of _down_ on body.\r\n    bodyDownX: 0, bodyDownY: 0,\r\n    // Current mouse position on body.\r\n    bodyMoveX: -1, bodyMoveY: -1,\r\n    // Last mouse position on body.\r\n    bodyMoveLastX: -1, bodyMoveLastY: -1,\r\n    // drag event.\r\n    onDrag: null,\r\n    // Last time tap for double tap detection.\r\n    lastTapTime: 0\r\n};\r\n\r\ndocument.body.addEventListener( 'mousedown', function(evt) {\r\n    if (G.touchDevice) return;\r\n    G.bodyDownX = evt.clientX;\r\n    G.bodyDownY = evt.clientY;\r\n    G.bodyMoveX = evt.clientX;\r\n    G.bodyMoveY = evt.clientY;\r\n    G.bodyMoveLastX = evt.clientX;\r\n    G.bodyMoveLastY = evt.clientY;\r\n}, true );\r\n\r\ndocument.body.addEventListener( 'mousemove', function(evt) {\r\n    if (G.touchDevice) return;\r\n    G.bodyMoveLastX = G.bodyMoveX;\r\n    G.bodyMoveLastY = G.bodyMoveY;\r\n    var rectB = evt.target.getBoundingClientRect();\r\n    G.bodyMoveX = evt.offsetX + rectB.left;\r\n    G.bodyMoveY = evt.offsetY + rectB.top;\r\n\r\n    if (!G.target) return;\r\n\r\n    var slots = G.target._slots;\r\n    if (typeof slots.drag !== 'function') return;\r\n\r\n    slots.drag({\r\n        action: 'drag',\r\n        target: G.target.element,\r\n        x0: G.targetX,\r\n        y0: G.targetY,\r\n        x: G.targetX + G.bodyMoveX - G.bodyDownX,\r\n        y: G.targetY + G.bodyMoveY - G.bodyDownY,\r\n        dx: G.bodyMoveX - G.bodyDownX,\r\n        dy: G.bodyMoveY - G.bodyDownY,\r\n        vx: G.bodyMoveX - G.bodyMoveLastX,\r\n        vy: G.bodyMoveY - G.bodyMoveLastY\r\n    });\r\n}, true );\r\n\r\ndocument.body.addEventListener( 'mouseup', function(evt) {\r\n    if (G.touchDevice) return;\r\n    if (!G.target) return;\r\n    evt.stopPropagation();\r\n    evt.preventDefault();\r\n\r\n    var time = Date.now();\r\n    var slots = G.target._slots;\r\n    var dx = G.bodyMoveX - G.bodyDownX;\r\n    var dy = G.bodyMoveY - G.bodyDownY;\r\n    if (slots.up) {\r\n        slots.up({\r\n            action: 'up',\r\n            target: G.target.element,\r\n            x: G.targetX + dx,\r\n            y: G.targetY + dy,\r\n            dx: dx,\r\n            dy: dy\r\n        });\r\n    }\r\n    // Tap or doubletap.\r\n    if (dx * dx + dy * dy < 256) {\r\n        if (G.lastTapTime > 0) {\r\n            if (slots.doubletap && time - G.lastTapTime < 400) {\r\n                slots.doubletap({\r\n                    action: 'doubletap',\r\n                    target: G.target.element,\r\n                    x: G.targetX + dx,\r\n                    y: G.targetY + dy\r\n                });\r\n            } else {\r\n                G.lastTapTime = 0;\r\n            }\r\n        }\r\n        if (slots.tap && G.lastTapTime == 0) {\r\n            slots.tap({\r\n                action: 'tap',\r\n                target: G.target.element,\r\n                x: G.targetX + dx,\r\n                y: G.targetY + dy\r\n            });\r\n        }\r\n        G.lastTapTime = time;\r\n    }\r\n    delete G.target;\r\n}, true);\r\n\r\n\r\nfunction PointerEvents( element ) {\r\n    var that = this;\r\n\r\n    this._slots = {};\r\n    this._eventListeners = [];\r\n\r\n    Object.defineProperty( PointerEvents.prototype, 'element', {\r\n        value: element, writable: false, configurable: true, enumerable: true\r\n    });\r\n\r\n    //===============\r\n    // Touch events.\r\n    addEvent.call(that, element, 'touchstart', function(evt) {\r\n        G.touchDevice = true;\r\n        var slots = that._slots;\r\n        if (evt.touches.length == 1) {\r\n            G.rect = element.getBoundingClientRect();\r\n            G.bodyMoveX = evt.touches[0].clientX;\r\n            G.bodyMoveY = evt.touches[0].clientY;\r\n            G.bodyDownX = evt.touches[0].clientX;\r\n            G.bodyDownY = evt.touches[0].clientY;\r\n            G.targetX = evt.touches[0].clientX - G.rect.left;\r\n            G.targetY = evt.touches[0].clientY - G.rect.top;\r\n            G.time = Date.now();\r\n            if (slots.down) {\r\n                slots.down({\r\n                    action: 'down',\r\n                    target: element,\r\n                    x: G.targetX,\r\n                    y: G.targetY,\r\n                    stopPropagation: evt.stopPropagation.bind( evt ),\r\n                    preventDefault: evt.preventDefault.bind( evt )\r\n                });\r\n            }\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'touchmove', function(evt) {\r\n        var lastX = G.bodyMoveX;\r\n        var lastY = G.bodyMoveY;\r\n        G.bodyMoveX = evt.touches[0].clientX;\r\n        G.bodyMoveY = evt.touches[0].clientY;\r\n        var slots = that._slots;\r\n        if (slots.drag) {\r\n            slots.drag({\r\n                action: 'drag',\r\n                target: element,\r\n                x0: G.targetX,\r\n                y0: G.targetY,\r\n                x: G.bodyMoveX - G.rect.left,\r\n                y: G.bodyMoveY - G.rect.top,\r\n                dx: G.bodyMoveX - G.bodyDownX,\r\n                dy: G.bodyMoveY - G.bodyDownY,\r\n                vx: G.bodyMoveX - lastX,\r\n                vy: G.bodyMoveY - lastY,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'touchend', function(evt) {\r\n        var slots = that._slots;\r\n        var dx = G.bodyMoveX - G.bodyDownX;\r\n        var dy = G.bodyMoveY - G.bodyDownY;\r\n        if (slots.up) {\r\n            slots.up({\r\n                action: 'up',\r\n                target: that.element,\r\n                x: G.bodyMoveX - G.rect.left,\r\n                y: G.bodyMoveY - G.rect.top,\r\n                dx: dx,\r\n                dy: dy,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n        // Tap or doubletap.\r\n        if (dx * dx + dy * dy < 256) {\r\n            var time = Date.now();\r\n            if (G.lastTapTime > 0) {\r\n                if (slots.doubletap && time - G.lastTapTime < 400) {\r\n                    slots.doubletap({\r\n                        action: 'doubletap',\r\n                        target: that.element,\r\n                        x: G.bodyMoveX - G.rect.left,\r\n                        y: G.bodyMoveY - G.rect.top,\r\n                        stopPropagation: evt.stopPropagation.bind( evt ),\r\n                        preventDefault: evt.preventDefault.bind( evt )\r\n                    });\r\n                } else {\r\n                    G.lastTapTime = 0;\r\n                }\r\n            }\r\n            if (slots.tap && G.lastTapTime == 0) {\r\n                evt.stopPropagation();\r\n                evt.preventDefault();\r\n                slots.tap({\r\n                    action: 'tap',\r\n                    target: that.element,\r\n                    x: G.bodyMoveX - G.rect.left,\r\n                    y: G.bodyMoveY - G.rect.top,\r\n                    stopPropagation: evt.stopPropagation.bind( evt ),\r\n                    preventDefault: evt.preventDefault.bind( evt )\r\n                });\r\n            }\r\n            G.lastTapTime = time;\r\n        }\r\n    });\r\n\r\n    //===============\r\n    // Mouse events.\r\n    addEvent.call(that, element, 'mousedown', function(evt) {\r\n        if (G.touchDevice) return;\r\n        var slots = that._slots;\r\n        var rect = element.getBoundingClientRect();\r\n        G.target = that;\r\n        G.targetX = evt.clientX - rect.left;\r\n        G.targetY = evt.clientY - rect.top;\r\n        if (slots.down) {\r\n            slots.down({\r\n                action: 'down',\r\n                target: element,\r\n                x: G.targetX,\r\n                y: G.targetY,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        }\r\n    });\r\n    addEvent.call(that, element, 'mousemove', function(evt) {\r\n        var slots = that._slots;\r\n        if (slots.move) {            \r\n            var rectA = element.getBoundingClientRect();\r\n            var rectB = evt.target.getBoundingClientRect();\r\n            slots.move({\r\n                target: element,\r\n                action: 'move',\r\n                x: evt.offsetX + rectB.left - rectA.left,\r\n                y: evt.offsetY + rectB.top - rectA.top\r\n            });\r\n        }\r\n    });\r\n\r\n    Object.defineProperty( this, 'element', {\r\n        value: element, writable: true, configurable: true, enumerable: true\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPointerEvents.prototype.on = function(action, event) {\r\n    var that = this;\r\n\r\n    var slots = this._slots;\r\n    if (typeof event === 'function') {\r\n        slots[action] = event;\r\n    }\r\n    if (action == 'wheel') {\r\n        addEvent.call(that, this.element, WHEEL_EVENT, function(evt) {\r\n            var rect = that.element.getBoundingClientRect();\r\n            slots.wheel({\r\n                target: that.element,\r\n                action: 'wheel',\r\n                delta: evt.deltaY,\r\n                x: evt.clientX - rect.left,\r\n                y: evt.clientY - rect.top,\r\n                stopPropagation: evt.stopPropagation.bind( evt ),\r\n                preventDefault: evt.preventDefault.bind( evt )\r\n            });\r\n        });\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * @return void\r\n */\r\nPointerEvents.prototype.off = function() {\r\n    this._eventListeners.forEach(function (itm) {\r\n        var element = itm[0];\r\n        var event = itm[1];\r\n        var listener = itm[2];\r\n        var capture = itm[3];\r\n        element.removeEventListener( event, listener, capture );\r\n    });\r\n};\r\n\r\n\r\nfunction addEvent(element, event, listener, capture) {\r\n    element.addEventListener( event, listener, capture );\r\n    this._eventListeners.push([element, event, listener, capture]);\r\n}\r\n\r\nmodule.exports = PointerEvents;\r\n\r\n\r\n  \r\nmodule.exports._ = _;\n});"],"names":["require","module","exports","PointerEvents","element","that","this","_slots","_eventListeners","Object","defineProperty","prototype","value","writable","configurable","enumerable","addEvent","call","evt","G","touchDevice","slots","touches","length","rect","getBoundingClientRect","bodyMoveX","clientX","bodyMoveY","clientY","bodyDownX","bodyDownY","targetX","left","targetY","top","time","Date","now","down","action","target","x","y","stopPropagation","bind","preventDefault","lastX","lastY","drag","x0","y0","dx","dy","vx","vy","up","lastTapTime","doubletap","tap","move","rectA","rectB","offsetX","offsetY","event","listener","capture","addEventListener","push","_","X","D","arguments","en","intl","all","WHEEL_EVENT","document","createElement","undefined","onmousewheel","bodyMoveLastX","bodyMoveLastY","onDrag","body","on","wheel","delta","deltaY","off","forEach","itm","removeEventListener"],"mappings":"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"},"dependencies":["mod/$"]}